/* -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
 *     Copyright 2017-Present Couchbase, Inc.
 *
 *   Use of this software is governed by the Business Source License included
 *   in the file licenses/BSL-Couchbase.txt.  As of the Change Date specified
 *   in that file, in accordance with the Business Source License, use of this
 *   software will be governed by the Apache License, Version 2.0, included in
 *   the file licenses/APL2.txt.
 */

#include <getopt.h>
#include <mcbp/mcbp.h>
#include <platform/dirutils.h>
#include <algorithm>
#include <iostream>

enum class Format { Raw, Gdb, Lldb };

Format parseFormat(std::string format) {
    std::transform(format.begin(), format.end(), format.begin(), toupper);
    if (format == "RAW") {
        return Format::Raw;
    }

    if (format == "GDB") {
        return Format::Gdb;
    }

    if (format == "LLDB") {
        return Format::Lldb;
    }

    throw std::invalid_argument("Unknown format: " + format);
}

int main(int argc, char** argv) {
    Format format{Format::Raw};

    static struct option longopts[] = {
            {"format", required_argument, nullptr, 'f'},
            {nullptr, 0, nullptr, 0}};

    int cmd;
    while ((cmd = getopt_long(argc, argv, "f:", longopts, nullptr)) != -1) {
        switch (cmd) {
        case 'f':
            try {
                format = parseFormat(optarg);
            } catch (const std::invalid_argument& e) {
                std::cerr << e.what() << std::endl;
                return EXIT_FAILURE;
            }
            break;
        default:
            std::cerr
                    << "Usage: " << cb::io::basename(argv[0])
                    << " [options] file1-n" << std::endl
                    << std::endl
                    << "\t--format=raw|gdb|lldb\tThe format for the input file"
                    << std::endl
                    << std::endl
                    << "For gdb the expected output would be produced by "
                       "executing: "
                    << std::endl
                    << std::endl
                    << "(gdb) x /24xb c->rcurr" << std::endl
                    << "0x7f43387d7e7a: 0x81 0x0d 0x00 0x00 0x00 0x00 0x00 0x00"
                    << std::endl
                    << "0x7f43387d7e82: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00"
                    << std::endl
                    << "0x7f43387d7e8a: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00"
                    << std::endl
                    << std::endl
                    << "For lldb the expected output would be generated by "
                       "executing: "
                    << std::endl
                    << std::endl
                    << "(lldb) x -c 32 c->rbuf" << std::endl
                    << "0x7f43387d7e7a: 81 0d 00 01 04 00 00 00 00 00 00 06 00 "
                       "00 00 06  ................"
                    << std::endl
                    << "0x7f43387d7e7a: 14 bf f4 26 8a e0 00 00 00 00 00 00 61 "
                       "61 81 0a  ................"
                    << std::endl
                    << std::endl;
            return EXIT_FAILURE;
        }
    }

    if (optind == argc) {
        std::cerr << "No file specified" << std::endl;
        return EXIT_FAILURE;
    }

    while (optind < argc) {
        try {
            cb::const_byte_buffer buf;
            std::vector<uint8_t> data;
            const auto payload = cb::io::loadFile(argv[optind]);
            buf = {reinterpret_cast<const uint8_t*>(payload.data()),
                   payload.size()};

            switch (format) {
            case Format::Raw:
                break;
            case Format::Gdb:
                data = cb::mcbp::gdb::parseDump(buf);
                buf = {data.data(), data.size()};
                break;
            case Format::Lldb:
                data = cb::mcbp::lldb::parseDump(buf);
                buf = {data.data(), data.size()};
                break;
            }

            cb::mcbp::dumpStream(buf, std::cout);

        } catch (const std::exception& error) {
            std::cerr << error.what() << std::endl;
            return EXIT_FAILURE;
        }

        ++optind;
    }

    return EXIT_SUCCESS;
}
